from abc import ABC, abstractmethod
from copy import deepcopy
from itertools import count

import numpy as np
import torch
import torch.nn as nn
from torch import Tensor, Size

from .nn import Actor


class ActionNoise(ABC):
    '''Random process for action exploration'''

    @abstractmethod
    def __call__(self, size: Size, device: torch.device) -> Tensor:
        ...


class Gaussian(ActionNoise):

    def __init__(self, stddev: float, decay_constant: float = 0):
        self.stddev = stddev
        self.decay_constant = decay_constant
        self._time = count(start=0, step=1)

    def __call__(self, size: Size, device: torch.device) -> Tensor:
        self.stddev = self.stddev * np.exp( -self.decay_constant * next(self._time) )
        return self.stddev * torch.randn(size, device=device)


class OrnsteinUhlenbeck(ActionNoise):
    '''
    It stabilises zero-mean Gaussian Noise.
    It helps agent explore better in an inertial system.
    Don't abuse Ornstein-Uhlenbeck Process. It has too much hyperparameters and over fine-tuning make no sense.
    '''

    def __init__(self):
        ...

    def __call__(self, size: Size, device: torch.device) -> Tensor:
        '''Output noise generated by Ornstein-Uhlenbeck Process'''
        ...


class AdaptiveParameterNoise:

    def __init__(self, stddev: float, desired_stddev: float, adoption_coefficient: float):
        self.stddev = stddev
        self.desired_stddev = desired_stddev
        self.adoption_coefficient = adoption_coefficient

    @torch.no_grad()
    def perturb(self, actor: Actor) -> Actor:
        perturbed_actor = deepcopy(actor)
        for param in perturbed_actor.parameters():
            param.requires_grad = False
        perturbed_actor.apply(self._add_gaussian_noise_to_weights)
        return perturbed_actor

    @torch.no_grad()
    def _add_gaussian_noise_to_weights(self, m: nn.Module):
        if hasattr(m, 'weight'):
            m.weight.add_(torch.randn(m.weight.size(), device=m.weight.device) * self.stddev)

    @torch.no_grad()
    def adapt(self, action: Tensor, perturbed_action: Tensor):
        stddev = torch.sqrt(torch.mean(torch.square(action - perturbed_action)))
        match stddev:
            case _ if stddev > self.desired_stddev:
                self.stddev *= self.adoption_coefficient
            case _ if stddev < self.desired_stddev:
                self.stddev /= self.adoption_coefficient
